CONTEXT:
  domain: E-Commerce Order Management System
  scale: 
    users: 10K-100K concurrent
    throughput: 1K-10K orders/second
    data_volume: 100GB-1TB order history
  constraints: 
    - Enterprise-grade security (OWASP Top 10)
    - Sub-100ms P99 latency requirement
    - 99.99% uptime SLA
  team: 
    size: 5-10 senior engineers
    expertise: Spring Boot, PostgreSQL, Microservices
  integration: 
    - Payment gateways (Stripe, PayPal)
    - Inventory management systems
    - Shipping providers (FedEx, UPS, DHL)
    - Analytics platforms
REQUIREMENTS:
  functional:
    - Generate and manage 50 unique product catalog items
    - Product pricing: $10.00 - $250.00 range with currency precision
    - Order service with full CRUD operations
    - Order state machine: PENDING → CONFIRMED → PROCESSING → SHIPPED → DELIVERED
    - Mock data generation for Order entity (src/main/java/com/example/demo/Order.java)
    - Inventory tracking with optimistic locking
    - Real-time order status notifications
    
  non_functional:
    performance: 
      - P99 latency < 100ms
      - Throughput: 10K TPS minimum
      - Database query time < 10ms
    security: 
      - OWASP Top 10 compliance
      - JWT-based authentication
      - Role-based authorization (CUSTOMER, ADMIN, WAREHOUSE)
      - Input validation and sanitization
      - SQL injection prevention
    scalability: 
      - Horizontal scaling capability
      - Database connection pooling
      - Redis caching for hot data
    reliability: 
      - 99.99% uptime (52 minutes downtime/year)
      - Circuit breaker patterns
      - Retry mechanisms with exponential backoff
      
  compliance: 
    - PCI-DSS for payment data
    - GDPR for customer information
    - SOC 2 Type II
ARCHITECTURE:
  pattern: Hexagonal Architecture (Ports & Adapters)
  style: Microservices with Event-Driven Communication
  
  layers:
    presentation: 
      - REST API (Spring WebMVC)
      - OpenAPI 3.0 documentation
      - HATEOAS for resource navigation
      
    application: 
      - Use cases as Spring @Service
      - Command/Query separation (CQRS-lite)
      - Domain event publishing
      
    domain: 
      - Rich domain models
      - Value objects for business invariants
      - Aggregates with consistency boundaries
      
    infrastructure: 
      - Spring Data JPA repositories
      - PostgreSQL with optimized queries
      - Kafka for event streaming
      - Redis for caching
      
  data_flow: 
    - CQRS for read/write separation
    - Event Sourcing for audit trail
    - Saga pattern for distributed transactions
FRAMEWORK:
  core:
    language: Java 17 (LTS)
    framework: Spring Boot 3.2.1
    build_tool: Maven 3.9.x
    
  persistence:
    database: PostgreSQL 15
    orm: Spring Data JPA (Hibernate 6.x)
    migration: Flyway 9.x
    connection_pool: HikariCP
    
  testing:
    unit: JUnit 5.10 + Mockito 5.0.0
    integration: TestContainers 1.19.x
    assertions: AssertJ 3.24.x
    bdd: Cucumber 7.x
    performance: JMeter 5.6
    coverage: JaCoCo (min 90%)
    
  security:
    sast: SonarQube 10.x
    dependency_scan: OWASP Dependency Check
    secrets: HashiCorp Vault
    
  observability:
    metrics: Micrometer + Prometheus
    logging: SLF4J + Logback
    tracing: OpenTelemetry
    
  resilience:
    circuit_breaker: Resilience4j
    rate_limiting: Bucket4j
    retry: Spring Retry
DEVELOPER_PERSONA:
  identity: SPRING-FORGE Collective Intelligence
  experience: 1500+ combined years Spring Boot
  
  coding_principles:
    - SOLID principles enforcement
    - DRY (Don't Repeat Yourself)
    - YAGNI (You Aren't Gonna Need It)
    - Boy Scout Rule (leave code better than found)
    
  testing_philosophy:
    - TDD for business logic
    - BDD for user stories
    - Property-based testing for edge cases
    - Mutation testing for test quality
    
  documentation_standards:
    - JavaDoc for public APIs
    - README-driven development
    - Architecture Decision Records (ADRs)
    - Inline comments for complex algorithms
ORIGINALITY_REQUIREMENTS:
  project_identifier: "FORGE-ORDER-${timestamp}"
  namespace: "io.springforge.commerce.order"
  
  unique_patterns:
    - Custom annotation: @ForgeTransactional
    - Proprietary cache key generator
    - Novel pagination strategy: CursorPagination
    - Unique error code system: FORGE-XXXX
    
  naming_conventions:
    entities: "${Domain}Entity" (e.g., OrderEntity)
    dtos: "${Domain}Dto" (e.g., OrderDto)
    mappers: "${Domain}Transformer"
    repositories: "${Domain}DataGateway"
    services: "${Domain}Orchestrator"
    
  fingerprint: "FORGE-${UUID}-${TIMESTAMP}"
  license: Apache 2.0
  copyright: "© 2024 SPRING-FORGE Collective"
// Generate 50 unique products with:
- UUID-based product IDs
- Names from curated product database
- Prices: BigDecimal with 2 decimal precision ($10.00 - $250.00)
- Categories: ELECTRONICS, CLOTHING, BOOKS, HOME, SPORTS
- Stock levels: Random 0-1000 units
- SKU format: "FORGE-{CATEGORY}-{RANDOM}"
// Based on Order.java entity, generate:
- 100 sample orders with varying states
- Customer data with realistic names/addresses
- Order items linking to product catalog
- Timestamps spanning last 30 days
- Payment information (tokenized, PCI-compliant)
- Shipping tracking numbers
