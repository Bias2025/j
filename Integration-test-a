// You are a world-class Spring Boot architect and testing expert with 50+ years of combined experience, specializing in enterprise-grade development patterns and best practices.
//
// CONTEXT: springboot 3.4 application working with appicant entity working with applicant entity
//
// REQUIREMENTS:
// Functional: CRUD operations with validation, Authentication and authorization, RESTful API endpoints
// Non-Functional: High performance (sub-second response), 99.9% uptime availability, Enterprise security standards, Clean, maintainable code structure, Comprehensive logging and monitoring, Efficient caching strategy
//
// ARCHITECTURE: Microservices architecture, Layered architecture (Controller-Service-Repository), Cloud-native design patterns, SOLID principles adherence, Event-driven architecture
//
// TESTING: Unit tests (80%+ coverage), Integration tests for APIs, End-to-end testing, Security testing (OWASP), Proper mocking and test doubles
//
// CONSTRAINTS:
// Quality: Minimum 80% code coverage, SonarQube quality gates compliance, Mutation testing score > 75%, Clean code principles (SOLID, DRY, KISS), Comprehensive JavaDoc/JSDoc documentation
// Performance: API response time < 500ms, Handle 1000+ concurrent requests, Memory usage < 512MB heap, Implement appropriate caching strategy
// Security: OWASP Top 10 vulnerability prevention, Cross-site scripting (XSS) protection, Comprehensive audit trail logging
//
// FRAMEWORKS: Spring Boot Test, java 17, Mockito 5+, spring boot 3.2+
//
// ORIGINALITY REQUIREMENTS:
// - Create UNIQUE implementation with custom business logic specific to applicant domain
// - Use distinctive variable names, method signatures, and class structures
// - Implement domain-specific validation rules and custom business constraints
// - Add unique error handling patterns and custom exception types
// - Include original comments explaining business context and implementation decisions
// - Avoid generic boilerplate patterns - create contextual, business-driven code
// - Use creative naming conventions that reflect the specific business domain
// - Implement custom utility methods and helper classes specific to this use case
//
// Generate comprehensive Spring Boot implementation that:
// - Follows enterprise patterns and SOLID principles with unique business logic
// - Includes extensive error handling with domain-specific error messages
// - Implements proper logging with contextual business information
// - Uses modern Java 17+ features in creative ways
// - Includes comprehensive test coverage with realistic business scenarios
// - Handles edge cases specific to applicant domain requirements
// - Follows security best practices with custom validation logic
// - Implements proper documentation with business context explanations
// - Adheres to specified quality gates with unique implementation approach
// - Creates original code structure that reflects specific business needs
/*
 * Generated with CRAFT method for GitHub Copilot - ORIGINALITY FOCUSED
 * This enterprise-grade prompt generates UNIQUE, production-ready code with:
 * - Custom business logic implementation tailored to your domain
 * - Original naming conventions and method signatures
 * - Domain-specific validation and error handling
 * - Unique test scenarios based on real business requirements
 * - Creative implementation patterns that avoid common boilerplate
 * - Contextual comments and documentation
 * 
 * IMPORTANT: Replace ALL placeholders with your specific business terms:
 * - [EntityName] → Your actual entity (User, Product, Order, etc.)
 * - [FeatureName] → Your specific feature (UserRegistration, PaymentProcessing, etc.)
 * - [MethodName] → Business-specific method names (validateUserCredentials, etc.)
 * - Add your domain-specific constraints and business rules
 * 
 * The more specific your business context, the more original the generated code will be!
 */
