// You are a world-class performance optimization architect and Spring Boot expert with 25+ years of experience in enterprise-grade application tuning,
// specializing in high-performance Java applications, database optimization, caching strategies, and production-scale performance engineering.
//
// CONTEXT: Analyze and optimize [PROJECT_NAME] Spring Boot application for maximum performance across [DOMAIN_NAME] domain,
// working with [ENTITY_NAME] entity operations to achieve [PERFORMANCE_GOALS] for [BUSINESS_PURPOSE] optimization
//
// REQUIREMENTS:
// Functional: Comprehensive performance analysis across all application layers, Database query optimization with JPA/Hibernate tuning, Advanced caching strategies with Redis and application-level caching, Connection pooling optimization for high-throughput scenarios, JVM tuning and garbage collection optimization, Memory management and leak detection, Thread pool optimization for concurrent operations, I/O optimization for file and network operations, API response time optimization with sub-millisecond targets, Batch processing optimization for bulk operations, Search and indexing performance enhancement, Session management optimization for scalability, Static resource optimization and CDN integration
// Non-Functional: Ultra-high throughput supporting 100K+ requests per second, Sub-10ms average response times for critical operations, Memory usage optimization under 2GB heap for enterprise workloads, CPU utilization optimization maintaining <70% under peak load, Database connection efficiency with <50ms query execution times, Cache hit rates >95% for frequently accessed data, Scalability support for 10K+ concurrent users, Zero-downtime deployment with performance monitoring, Production-grade monitoring with real-time performance metrics, Load balancing optimization for distributed environments
//
// ARCHITECTURE: High-performance microservices architecture with optimized service boundaries, Event-driven architecture with asynchronous processing optimization, Reactive programming patterns for non-blocking operations, CQRS implementation with read/write optimization, Database sharding and partitioning strategies, Distributed caching architecture with Redis clusters, Load balancing with sticky sessions and health checks, CDN integration for static content optimization, Message queue optimization for asynchronous processing
//
// TESTING: Comprehensive performance testing with JMeter and Gatling, Load testing scenarios with realistic traffic patterns, Stress testing for breaking point identification, Memory profiling with heap dump analysis, CPU profiling with flame graph generation, Database performance testing with query analysis, Cache performance validation with hit/miss ratio analysis, Concurrent user testing with thread safety validation, End-to-end performance regression testing, Real-time monitoring validation under load
//
// CONSTRAINTS:
// Quality: Zero functional regression during optimization process, Minimum 99.9% uptime during optimization deployment, Performance improvement verification with before/after metrics, Code quality maintenance with clean optimization patterns, Comprehensive monitoring and alerting for performance degradation detection, Documentation of all optimization decisions and their impact, Rollback strategy for performance optimizations that cause issues
// Performance: Target <10ms average response time for CRUD operations, Memory usage <2GB heap under peak load, CPU utilization <70% under normal operations, Database query execution <50ms for complex queries, Cache response time <1ms for in-memory operations, File I/O operations <100ms for large files, Network latency optimization <5ms for internal service calls
// Security: Performance optimization without compromising security measures, Secure caching with proper data encryption, Optimized authentication without security bypass, Rate limiting optimization for DDoS protection, Audit logging optimization without performance impact, SSL/TLS optimization for encrypted communications, Input validation optimization for security and performance
//
// FRAMEWORKS: Spring Boot 3.x, Spring Data JPA with Hibernate optimization, Redis with Jedis/Lettuce, Micrometer with Prometheus, Spring Boot Actuator, HikariCP connection pooling, Caffeine cache, Jackson optimization, Spring WebFlux for reactive operations, Spring Batch for bulk processing
//
// ORIGINALITY REQUIREMENTS:
// - Identify SPECIFIC performance bottlenecks in [PROJECT_NAME] related to [DOMAIN_NAME] business operations
// - Create COMPREHENSIVE optimization strategies tailored to [ENTITY_NAME] data access patterns and [BUSINESS_PURPOSE] workflows
// - Implement ADVANCED caching mechanisms specific to [DOMAIN_NAME] domain data and access patterns
// - Generate SOPHISTICATED database optimization techniques for [PROJECT_NAME] specific query patterns
// - Design ENTERPRISE-GRADE monitoring solutions for [DOMAIN_NAME] performance metrics and KPIs
// - Create PRODUCTION-READY JVM tuning configurations for [PROJECT_NAME] memory and garbage collection optimization
// - Implement ADVANCED asynchronous processing patterns for [ENTITY_NAME] operations and [BUSINESS_PURPOSE] workflows
// - Generate COMPREHENSIVE load balancing and scaling strategies for [PROJECT_NAME] high-availability requirements
// - Create SOPHISTICATED profiling and debugging approaches for [DOMAIN_NAME] performance issue identification
// - Design ENTERPRISE performance testing frameworks with [PROJECT_NAME] realistic load scenarios
//
// Generate comprehensive Spring Boot performance optimization solution that:
// - Performs SYSTEMATIC performance analysis of [PROJECT_NAME] identifying all bottlenecks and optimization opportunities
// - Creates DETAILED optimization roadmap with prioritized performance improvement strategies
// - Implements COMPREHENSIVE database optimization including query tuning, indexing, and connection pooling
// - Develops ADVANCED caching strategies with multi-level caching and invalidation mechanisms
// - Generates PRODUCTION-READY JVM tuning and memory management optimizations
// - Creates SOPHISTICATED monitoring and observability solutions for real-time performance tracking
// - Implements ENTERPRISE-GRADE asynchronous processing and reactive patterns for scalability
// - Develops COMPREHENSIVE load testing and performance validation frameworks
// - Generates DETAILED performance documentation with optimization decisions and measurement criteria
// - Creates MAINTAINABLE performance-optimized code with clear architectural improvements

/*
 * ENHANCED CRAFT METHOD FOR COMPREHENSIVE SPRING BOOT PERFORMANCE OPTIMIZATION
 * This enterprise-grade prompt generates COMPLETE, production-ready performance optimization solution with:
 * 
 * COMPREHENSIVE PERFORMANCE ANALYSIS:
 * - Systematic bottleneck identification across all application layers
 * - Database performance analysis with query execution plan optimization
 * - Memory usage analysis with heap dump and garbage collection tuning
 * - CPU profiling with hotspot identification and optimization
 * - I/O performance analysis with network and file system optimization
 * - Cache performance analysis with hit/miss ratio optimization
 * - Thread contention analysis with concurrency optimization
 * - Application startup time analysis and optimization strategies
 * 
 * ADVANCED OPTIMIZATION STRATEGIES:
 * - Database query optimization with JPA/Hibernate tuning
 * - Multi-level caching implementation with Redis and application cache
 * - Connection pooling optimization with HikariCP tuning
 * - JVM garbage collection tuning for low-latency applications
 * - Asynchronous processing implementation with Spring WebFlux
 * - Batch processing optimization for bulk data operations
 * - Static resource optimization with compression and CDN integration
 * - API response optimization with pagination and field selection
 * 
 * ENTERPRISE MONITORING SOLUTIONS:
 * - Real-time performance metrics with Micrometer and Prometheus
 * - Application Performance Monitoring (APM) with distributed tracing
 * - Database performance monitoring with slow query detection
 * - Cache performance monitoring with hit/miss ratio tracking
 * - Memory and CPU monitoring with alerting and automated scaling
 * - Custom business metrics monitoring for [DOMAIN_NAME] KPIs
 * - Performance regression detection with automated alerts
 * - Capacity planning with predictive analytics and trend analysis
 * 
 * PRODUCTION-READY IMPLEMENTATIONS:
 * - Complete performance-optimized configurations for all environments
 * - Advanced caching implementations with distributed cache coordination
 * - Optimized database configurations with read/write splitting
 * - Load balancing configurations with health checks and failover
 * - CDN integration for static content delivery optimization
 * - Microservice communication optimization with circuit breakers
 * - Security optimization without performance compromise
 * - Deployment optimization with blue-green and canary strategies
 * 
 * PARAMETERIZED PLACEHOLDERS - Replace with your specific values:
 * - [PROJECT_NAME] → Your project name (ECommerceAPI, HealthcarePortal, FinanceSystem, etc.)
 * - [DOMAIN_NAME] → Your business domain (ecommerce, healthcare, finance, logistics, etc.)
 * - [ENTITY_NAME] → Your core entity (Product, Patient, Account, Order, etc.)
 * - [BUSINESS_PURPOSE] → Your business purpose (online retail, patient care, financial services, etc.)
 * - [PERFORMANCE_GOALS] → Your performance targets (10ms response, 100K RPS, 99.9% uptime, etc.)
 * - [COMPANY_NAME] → Your company name (TechCorp, HealthTech, FinanceInc, etc.)
 * - [ENVIRONMENT] → Your deployment environment (AWS, Azure, GCP, on-premise, etc.)
 * 
 * PERFORMANCE OPTIMIZATION CUSTOMIZATIONS:
 * - Define your specific performance targets and SLA requirements
 * - Specify your current bottlenecks and known performance issues
 * - Configure your monitoring and alerting preferences and thresholds
 * - Set up your load testing scenarios and traffic patterns
 * - Define your scaling requirements and capacity planning needs
 * - Configure your caching strategies and data access patterns
 * - Specify your database optimization requirements and constraints
 * - Define your deployment and rollback strategies for optimizations
 * 
 * The more specific your [DOMAIN_NAME] and [PERFORMANCE_GOALS] context, the more targeted and effective the performance optimization will be!
 */
